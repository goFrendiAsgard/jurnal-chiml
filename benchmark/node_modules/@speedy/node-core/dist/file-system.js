var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cpx_1 = require("cpx");
const _ = require("lodash");
const rimraf = require("rimraf");
const glob_1 = require("glob");
const fs_1 = require("fs");
const path_1 = require("path");
var fileSystem;
(function (fileSystem) {
    fileSystem.getRootPath = _.once(() => findFileRecursively() || "");
    function deleteAsync(path) {
        // tslint:disable-next-line:no-shadowed-variable
        return new Promise((resolve, reject) => {
            rimraf(path, error => {
                if (error) {
                    return reject(error);
                }
                return resolve(true);
            });
        });
    }
    fileSystem.deleteAsync = deleteAsync;
    function readFileAsync(path) {
        // tslint:disable-next-line:no-shadowed-variable
        return new Promise((resolve, reject) => {
            fs_1.readFile(path, "utf-8", (error, data) => {
                if (error) {
                    return reject(error);
                }
                return resolve(data);
            });
        });
    }
    fileSystem.readFileAsync = readFileAsync;
    function readJsonFileAsync(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return JSON.parse(yield readFileAsync(path));
        });
    }
    fileSystem.readJsonFileAsync = readJsonFileAsync;
    function glob(patterns) {
        const paths = _.castArray(patterns);
        const ignoredPatterns = _.chain(paths)
            .filter(x => _.startsWith(x, "!"))
            .map(x => _.trimStart(x, "!"))
            .value();
        return _.chain(paths)
            .filter(x => !_.startsWith(x, "!"))
            .flatMap(x => glob_1.sync(x, { ignore: ignoredPatterns }))
            .value();
    }
    fileSystem.glob = glob;
    /**
     * Find a file recursively in the file system from the starting path upwards.
     *
     * Defaults: fileName: package.json, startPath: process.cwd()
     *
     * @param {string} [fileName="package.json"]
     * @param {string} [startPath=process.cwd()]
     * @returns {(string | undefined)}
     */
    function findFileRecursively(fileName = "package.json", startPath = process.cwd()) {
        startPath = path_1.normalize(startPath);
        try {
            const directory = path_1.join(startPath, path_1.sep);
            fs_1.statSync(path_1.join(directory, fileName));
            return directory;
        }
        catch (error) {
            // do nothing
        }
        let position = _.lastIndexOf(startPath, path_1.sep);
        if (position < 0) {
            return undefined;
        }
        const truncatedPath = startPath.substr(0, position++);
        return findFileRecursively(fileName, truncatedPath);
    }
    fileSystem.findFileRecursively = findFileRecursively;
    /**
     * Get a canonicalized absolute path
     *
     * @export
     * @param {string} path
     * @returns {string} canonicalized absolute path
     */
    function getCanonicalPath(path) {
        return path_1.resolve(process.cwd(), path);
    }
    fileSystem.getCanonicalPath = getCanonicalPath;
    /**
     * Copy an array of file globs
     * @param source The glob of target files
     * @param destination The path of a destination directory
     */
    function copyAsync(source, destination) {
        return Promise.all(_.chain(source)
            .castArray()
            .map(x => new Promise((resolve, reject) => {
            cpx_1.copy(x, destination, (error) => error ? reject(error) : resolve());
        }))
            .value());
    }
    fileSystem.copyAsync = copyAsync;
})(fileSystem = exports.fileSystem || (exports.fileSystem = {}));
